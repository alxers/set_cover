<html>
  <body></body>
  <script>

    //
    // var test = [
    //   [1, 0, 0, 1],
    //   [1, 1, 1, 1],
    //   [0, 1, 1, 0],
    //   [1, 1, 1, 1]
    // ];

    //

    var initialMatr = [
        [1, 0, 0, 1, 0, 0, 0, 1, 0, 0],
        [0, 1, 0, 0, 0, 1, 1, 0, 0, 0],
        [0, 1, 1, 0, 1, 0, 0, 1, 0, 0],
        [0, 0, 1, 1, 0, 0, 0, 1, 0, 1],
        [0, 0, 0, 1, 0, 0, 1, 0, 0, 0],
        [1, 0, 1, 0, 0, 1, 0, 0, 1, 0],
        [0, 1, 0, 0, 1, 0, 1, 0, 0, 0],
        [1, 0, 0, 0, 1, 0, 0, 1, 1, 0],
        [1, 0, 1, 0, 1, 0, 1, 0, 0, 1],
    ];

    // m = normalizeMatr(m);

    // printMatr(m);

    // console.log('---------');
    // var x = maxRow(m);
    // console.log(x);

    // var currentCoverage = [];

    // // Algo start
    // // 1. Find column with min amount of 1's
    // var colToCheck = minCol(m);

    // // 2. Choose rows, that cover the column from step 1.
    // var rowsToCheck = rowsThatCoverCol(colToCheck);

    // // 3. Check which row from previous step has the most coverage among the initial matrix
    // // This row also should be added to the minimal coverage
    // var rowNum = rowToRemove(rowsToCheck);
    // // 
    // // currentCoverage.push(m[rowNum].slice(0));
    // // Save index instead of a row for now
    // currentCoverage.push(rowNum);

    // // 4. Find columns that cover the row from the previous step.
    // // Check where this row has 1's, remove columns on these indexes
    // var colsToRemove = colsThatCoverRow(rowNum);

    // // 5. Remove these columns
    // var firstRun = true;
    // var newM;
    // var acc = 1;
    // for (var i = 0; i < colsToRemove.length; i++) {
    //   if (firstRun) {
    //     newM = removeCol(m, colsToRemove[i]);
    //     firstRun = false;
    //   } else {
    //     // Matrix indexes will be shifter after first removal
    //     newM = removeCol(newM, colsToRemove[i] - acc);
    //     acc++;
    //   }
    // }

    // // Remove the row
    // newM = removeRow(newM, rowNum);
    // printMatr(newM);

    // Algo end

    // Test run1
    var currentCoverage = [];
    m = normalizeMatr(initialMatr);
    while(true) {
      m = normalizeMatr(m);
      // Algo start
      // 1. Find column with min amount of 1's
      var colToCheck = minCol(m);

      // 2. Choose rows, that cover the column from step 1.
      var rowsToCheck = rowsThatCoverCol(m, colToCheck);

      // 3. Check which row from previous step has the most coverage among the initial matrix
      // This row also should be added to the minimal coverage
      var rowNum = rowToRemove(m, rowsToCheck);
      if (rowNum < 0) {
        break;
      }
      // 
      currentCoverage.push(m[rowNum].slice(0));
      // Save index instead of a row for now
      // currentCoverage.push(rowNum);

      // 4. Find columns that cover the row from the previous step.
      // Check where this row has 1's, remove columns on these indexes
      var colsToRemove = colsThatCoverRow(m, rowNum);

      // 5. Remove these columns
      var newM;
      newM = removeMultiple(m, colsToRemove, false);

      // Remove the row
      newM = removeRow(newM, rowNum);
      console.log('---------------');
      printMatr(newM);
      console.log('---------------');

      m = newM;

      // Algo end
    }
    // End Test run1

    // Helper functions

    function colsThatCoverRow(matr, rowNum) {
      var cols = [];
      for (var i = 0; i < matr[rowNum].length; i++) {
        if (matr[rowNum][i]) {
          cols.push(i);
        }
      }

      return cols;
    }

    function rowToRemove(matr, rows) {
      var rowToRemove = -1;
      var maxSum = 0;
      var currSum = 0;
      for (var i = 0; i < rows.length; i++) {
        currSum = matr[rows[i]].reduce((a, b) => a + b, 0);
        if (currSum > maxSum) {
          maxSum = currSum;
          rowToRemove = rows[i];
        }
      }

      return rowToRemove;
    }

    function rowsThatCoverCol(matr, col) {
      var a = [];
      for (var i = 0; i < matr.length; i++) {
        if (matr[i][col]) {
          a.push(i);
        }
      }

      return a;
    }

    function removeCol(array, remIdx) {
      return array.map(function(arr) {
        return arr.filter(function(el,idx){return idx !== remIdx});  
      });
    };

    function removeRow(arr, row) {
      arr = arr.slice(0); // make copy
      arr.splice(row,1)
      return arr;
    };

    function minCol(matr) {
      // Find colum with min amout of 1s
      // minSum has to be something other than 0
      // in the beginning
      var minColSum = matr.length;
      var colSum;
      var colNum;
      for (var col = 0; col < matr[0].length; col++) {
        colSum = 0;
        for (var row = 0; row < matr.length; row++) {
          colSum += matr[row][col];
        }

        if (colSum < minColSum) {
          minColSum = colSum;
          colNum = col;
        }
      }

      return colNum;
    }

    function maxRow(matr) {
      // // Find row with max amount of 1s
      var maxRowSum = 0;
      var currRowSum = 0;
      var rowNum = 0;
      for (var i = 0; i < matr.length; i++) {
        currRowSum = 0;
        for (var j = 0; j < matr[0].length; j++) {
          currRowSum += matr[i][j];

          if (currRowSum > maxRowSum) {
            rowNum = i;
            maxRowSum = currRowSum;
          }
        }
      }

      return rowNum;
    }

    function printMatr(matr) {
      var printText = '';

      for (var i = 0; i < matr.length; i++) {
        for (var j = 0; j < matr[0].length; j++) {
          printText += matr[i][j] + ' ';
        }
        console.log(printText);
        printText = '';
      }
    }

    // function removeDuplicatedRowsCols(matr) {
    //   var tmp;
    //   tmp = matr.map(JSON.stringify).reverse().filter(function (e, i, a) {
    //       return a.indexOf(e, i+1) === -1;
    //   }).reverse().map(JSON.parse);

    //   tmp = transpose(tmp);

    //   tmp = tmp.map(JSON.stringify).reverse().filter(function (e, i, a) {
    //       return a.indexOf(e, i+1) === -1;
    //   }).reverse().map(JSON.parse);

    //   return transpose(tmp);
    // }

    // var test1 = [
    //   [0, 1, 0, 0, 1, 0],
    //   [1, 0, 0, 1, 0, 0],
    //   [1, 0, 1, 0, 1, 0],
    //   [0, 1, 0, 0, 1, 1],
    //   [0, 1, 0, 1, 0, 0],
    //   [1, 0, 1, 1, 0, 0],
    //   [0, 0, 1, 0, 1, 0],
    //   [0, 0, 1, 1, 0, 1]
    // ];

    function normalizeMatr(matr) {
      // The row A is removed if there is another row B that
      // contains 1's on the same places and row A's sum is smaller than B's.
      // Same with columns.

      var rowsToDelete = determineRowsToDelete(matr);
      // console.log(rowsToDelete);

      if (!rowsToDelete.length) {
        return matr;
      }

      // Remove these rows
      var newM = removeMultiple(matr, rowsToDelete);

      // TODO: do not use transpose!
      // For now we transpose the initial matrix to find
      // the columns that can be removed
      // But the removal itself is done for the matrix for which we also remove rows
      newNewM = transpose(matr);
      var rowsToDelete = determineRowsToDelete(newNewM);
      // console.log(rowsToDelete);

      if (!rowsToDelete.length) {
        return newM;
      }

      newM = transpose(newM);
      newM = removeMultiple(newM, rowsToDelete);
      newM = transpose(newM);

      return newM;
    }

    // this function contains indexes of 1's in a row
    function posOfOnes(matr, row) {
      var arr = [];
      for (var i = 0; i < matr[row].length; i++) {
        if (matr[row][i]) {
          arr.push(i);
        }
      }

      return arr;
    }

    function determineRowsToDelete(matr) {
      var posOfOnesCurr;
      var posOfOnesNext;
      var lineCovered;
      var rowsToDelete = [];
      for (var i = 0; i < matr.length; i++) {
        posOfOnesCurr = posOfOnes(matr, i);
        for (var j = i+1; j < matr.length; j++) {
          posOfOnesNext = posOfOnes(matr, j);
          lineCovered = posOfOnesCurr.filter(value => posOfOnesNext.includes(value));
          if ((lineCovered.length === posOfOnesCurr.length) || (lineCovered.length === posOfOnesNext.length)) {
            if (posOfOnesCurr.length < posOfOnesNext.length) {
              rowsToDelete.push(i);
            } else {
              rowsToDelete.push(j);
            }
          }
        }
      }

      return rowsToDelete;
    }

    function removeMultipleRows(matr, rowsToDelete) {
      var firstRun = true;
      var newM;
      var acc = 1;
      for (var i = 0; i < rowsToDelete.length; i++) {
        if (firstRun) {
          newM = removeRow(matr, rowsToDelete[i]);
          firstRun = false;
        } else {
          // Matrix indexes will be shifter after first removal
          newM = removeRow(newM, rowsToDelete[i] - acc);
          acc++;
        }
      }
      return newM;
    }

    function removeMultiple(matr, toDelete, rows=true) {
      var f;
      if (rows) {
        f = removeRow;
      } else {
        f = removeCol;
      }
      var firstRun = true;
      var newM;
      var acc = 1;
      for (var i = 0; i < toDelete.length; i++) {
        if (firstRun) {
          newM = f(matr, toDelete[i]);
          firstRun = false;
        } else {
          // Matrix indexes will be shifter after first removal
          newM = f(newM, toDelete[i] - acc);
          acc++;
        }
      }
      return newM;
    }

    function transpose(matrix) {
      return matrix[0].map((col, i) => matrix.map(row => row[i]));
    }
  </script> 
</html>
